import sqlite3
import os
from mOTUlizer import _quiet_
from mOTUlizer.utils import parse_fasta
from enum import Enum, auto
import json
from sourmash.signature import save_signatures, load_signatures
from sourmash.signature import SourmashSignature
from sourmash import MinHash
import re
from tqdm import tqdm

seq_types = {'amino_acids', 'nucleotides'}

class SeqDb:
    seq_db = None

    @classmethod
    def init_db(cls, path = None):
        cls.seq_db = SeqDb(path)

    @classmethod
    def get_global_db(cls):
        return cls.seq_db

    def __repr__(self) :
        return f"< SQLite3-based Sequence DB located at {self.path} >"

    def __init__(self, path):
        if not path:
            self.path = tempfile.NamedTemporaryFile().name
            self.temp = True
        else :
            self.path = path
            self.temp = False

        if not os.path.exists(path):
            if not _quiet_:
                print("creating db")
            self._connection = sqlite3.connect(self.path)
            self.create_db()
        else :
            if not _quiet_:
                print("loading db")
            self._connection = sqlite3.connect(self.path)
            self.check_db()
        self._open_cursor = None

    def __del__(self):
        self._connection.close()
        if self.temp:
            os.remove(self.path)

    def create_db(self):
        cursor = self._connection.cursor()

        cursor.execute('''
                    CREATE TABLE "genomes" (
                    	"genome_name"	TEXT,
                    	"source"	TEXT,
                        "annotations" TEXT,
                        "taxonomy" TEXT,
                        "completeness" REAL,
                        "redundancy" REAL,
                        "signature" TEXT,
                    	PRIMARY KEY("genome_name")
                    );
                  ''')

        cursor.execute('''
                    CREATE TABLE "anis" (
                    	"query_name"	TEXT,
                    	"subject_name"	TEXT,
                        "ani"  REAL,
                        "query_chunks" INTEGER,
                        "reference_chunks" INTEGER,
                    	PRIMARY KEY("query_name", "subject_name"),
                    	FOREIGN KEY("query_name") REFERENCES genomes("genome_name"),
                    	FOREIGN KEY("subject_name") REFERENCES genomes("genome_name")
                    );
                  ''')


        cursor.execute('''
                    CREATE TABLE "contigs"  (
                    	"contig_name"	TEXT,
                    	"sequence"	TEXT,
                    	"genome_name"	TEXT,
                        "annotations" TEXT,
                    	PRIMARY KEY("contig_name"),
                    	FOREIGN KEY("genome_name") REFERENCES genomes("genome_name")
                    );
                  ''')

        cursor.execute('''
                    CREATE TABLE "gene_clusters"  (
                    	"gc_name"	TEXT,
                    	"annotations"	TEXT,
                        "alignment" TEXT,
                        "tree" TEXT,
                    	PRIMARY KEY("gc_name")
                    );
                  ''')

        cursor.execute('''
                    CREATE INDEX "gene_clusterings"
                    ON gene_clusters("clustering_run");
                  ''')

        cursor.execute('''
                    CREATE TABLE "gc2feature"  (
                    	"gc_name"	TEXT,
                    	"feature_id"	TEXT,
                    	FOREIGN KEY("gc_name") REFERENCES gene_clusters("gc_name")
                    	FOREIGN KEY("feature_id") REFERENCES features("feature_id")
                    );
                  ''')

        cursor.execute('''
                    CREATE INDEX "feature2gc"
                    ON gc2feature("feature_id");
                  ''')



        cursor.execute('''
                    CREATE TABLE "mOTUs"  (
                    	"motu_name"	TEXT,
                    	"taxonomy"	TEXT,
                    	PRIMARY KEY("motu_name")
                    );
                  ''')

        cursor.execute('''
                    CREATE TABLE "genome2motu"  (
                    	"motu_name"	TEXT,
                    	"genome_name"	TEXT,
                    	FOREIGN KEY("genome_name") REFERENCES genomes("genome_name")
                    	FOREIGN KEY("motu_name") REFERENCES mOTUs("motu_name")
                    );
                  ''')

        cursor.execute('''
                    CREATE INDEX "motu2genome"
                    ON genome2motu("genome_name");
                  ''')

        cursor.execute('''
                    CREATE INDEX "genome_to_contigs"
                    ON contigs("genome_name");
                  ''')

        cursor.execute('''
                    CREATE TABLE "features" (
                        "contig_name"   TEXT,
                    	"feature_id"	INTEGER,
                    	"name"	TEXT,
                    	"source"	TEXT,
                    	"feature"	TEXT,
                    	"start"	INTEGER,
                    	"end"	INTEGER,
                    	"score"	TEXT,
                    	"strand"	TEXT,
                    	"frame"	TEXT,
                    	"amino_acids"	TEXT,
                    	"nucleotides"	TEXT,
                        "annotations" TEXT,
                    	PRIMARY KEY("feature_id" AUTOINCREMENT),
                        FOREIGN KEY("contig_name") REFERENCES contigs("contig_name")

                    );
                  ''')

        cursor.execute('''
                    CREATE INDEX "contig_to_features"
                    ON features("contig_name");
                  ''')

        cursor.execute('''
                    CREATE INDEX "name_to_features"
                    ON features("name");
                  ''')


        self._connection.commit()



    @property
    def open_cursor(self):
        if not self._open_cursor:
            self._operation_counter = 1
            self._open_cursor = self._connection.cursor()
        else :
            self._operation_counter += 1
        return self._open_cursor

    def commit(self):
        self._connection.commit()
        self._open_cursor = None


    def bunched_query(func):
        def wrapper(*args, **kwargs):
            func(*args, **kwargs)
            if not 'bunched' in kwargs or not kwargs['bunched']:
                args[0].commit()
        return wrapper

    @bunched_query
    def add_genome(self, genome_name : str, source : str = '', contigs : dict = {}, annotations : dict = None, taxonomy = None, completeness = None, redundancy = None, signature = None, bunched = False):
        # contigs is list of dicts dicts with keys  'contig_name' 'sequence' and optinally 'annotations'
        # features is list of dicts with keys 'sequence' and optionaly 'annotations'


        if self.has_genome(genome_name):
            raise DataBaseBadValuesError(f"Genome {genome_name} is already in the database")

        if annotations:
            annotations = json.dumps(annotations).replace('"', '""')

        if taxonomy:
            taxonomy = json.dumps(taxonomy).replace('"', '""')

        if signature:
            if type(signature) == dict:
                mh = MinHash(**signature)
                for c in contigs:
                    mh.add_sequence(c['sequence'], force = True)
                signature = save_signatures([SourmashSignature(mh)])

        self.open_cursor.execute(f"""
        INSERT INTO genomes (genome_name,source, annotations, taxonomy, completeness, redundancy, signature)
        VALUES (?, ?, ?, ?, ?, ?, ?);
        """, (genome_name, source, annotations, taxonomy, completeness, redundancy, signature))
        if contigs:
            self.add_contigs(genome_name, contigs, bunched = bunched)

    @bunched_query
    def add_contigs(self, genome_name : str, contigs : dict , bunched = False):
        contigs = [(v['contig_name'], v['sequence'], genome_name, v.get('annotations', {})) for v in contigs]
        values = " , ".join([ f'("{a}", "{b}", "{c}", "{d}")' for a,b,c,d in contigs ])
        self.open_cursor.execute(f"""
        INSERT INTO contigs (contig_name,sequence,genome_name, annotations)
        VALUES {values};
        """)

    @bunched_query
    def add_features(self, genome_name : str, features : dict, source : str = "" , bunched = False):
        if features :
            fields = ["contig_name" , "source" , "feature" ,"start","end","score" ,"strand" , "frame", "name", "annotations", "amino_acids", "nucleotides"]
            values = " , ".join([ "(" + ",".join(['"{}"'.format(v.get(f,"")) for f in fields]) + ")" for v in features ])
            self.open_cursor.execute(f"""
            INSERT INTO features ({",".join(fields)})
            VALUES {values};
            """)

    @bunched_query
    def add_anis(self, ani_dict : dict, bunched = False):
        fields = ["query_name", "subject_name" , "ani" , "query_chunks" , "reference_chunks"]

        values = " , ".join([ f'( "{k[0]}", "{k[1]}" , ' + ",".join(['"{}"'.format(v.get(f,"")) for f in fields[2:]]) + ")" for k,v in ani_dict.items() ])
        self.open_cursor.execute(f"""
        INSERT INTO anis ({",".join(fields)})
        VALUES {values};
        """)

    @bunched_query
    def add_mOTU(self, motu_name : str, genomes : list, bunched = False):
        self.open_cursor.execute(f"""
        INSERT INTO mOTUs (motu_name)
        VALUES (?);
        """, (motu_name,))
        self.open_cursor.executemany(f"""
        INSERT INTO genome2motu (motu_name, genome_name)
        VALUES (?,?);
        """, [(motu_name, g) for g in genomes])


    @bunched_query
    def update_anis(self, ani_dict : dict, bunched = False):
        genomes = {kk for k in ani_dict for kk in k}
        values = " , ".join([ f'"{kk}"' for kk in genomes ])
        self.open_cursor.execute(f"""
        DELETE FROM anis
        WHERE "query_name" IN ({values});
        """)
        self.open_cursor.execute(f"""
        DELETE FROM anis
        WHERE "subject_name" IN ({values});
        """)
        self.add_anis(ani_dict)

    @bunched_query
    def update_taxonomy(self, tax_dict : dict, bunched = False):
        current_tax = self.get_taxonomy(tax_dict.keys())
        for k,v in tax_dict.items():
            current_tax[k].update(v)
        for c in current_tax:
            self.set_value("genome", c, "taxonomy", json.dumps(current_tax[c]).replace('"', '""'))

    @bunched_query
    def set_value(self, database, key, column, value):
        self.open_cursor.execute(f"""
        UPDATE ?(?)
        VALUES (?)
        WHERE key=?;
        """, (database, column, value, key))


    def delete_genome(self, genome_name : str):
        pass

    def has_genome(self, genome_name):
        self.open_cursor.execute(f"""
        SELECT genome_name FROM genomes WHERE genome_name="{genome_name}";
        """)
        return len(self.open_cursor.fetchall()) == 1

    def has_features(self, genome_name):
        self.open_cursor.execute(f"""
        SELECT feature_id FROM features INNER JOIN contigs on contigs.contig_name = features.contig_name WHERE genome_name = ? LIMIT 1 ;
        """, (genome_name,))
        return len(self.open_cursor.fetchall()) > 1

    def has_mOTU(self, motu_name):
        self.open_cursor.execute(f"""
        SELECT motu_name FROM mOTUs WHERE motu_name="{motu_name}";
        """)

        return len(self.open_cursor.fetchall()) == 1



    def get_anis(self, genomes):
        genome_names = " ( " + ",".join([f' "{g1.name}" ' for g1 in genomes]) + " ) "

        self.open_cursor.execute(f"""
        SELECT query_name, subject_name, ani,query_chunks, reference_chunks  FROM anis
        WHERE query_name IN {genome_names} AND subject_name in {genome_names} ;
        """)
        anis = self.open_cursor.fetchall()
        return { (v[0],v[1]) : {'ani' : v[2], 'query_chunks' : v[3], 'reference_chunks' : v[4]} for v in anis}

    def get_mOTU(self, motu):
        self.open_cursor.execute(f"""
        SELECT genome_name FROM genome2motu
        WHERE motu_name=? ;
        """, (motu,))
        genomes = self.open_cursor.fetchall()
        return [g[0] for g in genomes]

    def get_genomesFromFeat(self, feat):
        self.open_cursor.execute(f"""
        SELECT genome_name FROM contigs
        WHERE features.feature_id = ? AND features.contig_name = contigs.contig_name;
        """, (feat,))
        genomes = self.open_cursor.fetchall()
        return [g[0] for g in genomes]

    def list_mOTUs(self):
        self.open_cursor.execute(f"""
        SELECT motu_name FROM mOTUs ;
        """)
        motus = [m[0] for m in self.open_cursor.fetchall()]
        return {m : self.get_mOTU(m) for m in motus}

    def get_features(self, gene_cluster):
        self.open_cursor.execute(f"""
        SELECT feature_id FROM gene_clusters WHERE gc_name=?;
        """, (gene_cluster,))
        features = [m[0] for m in self.open_cursor.fetchall()]
        return features

    def get_features_seq(self, features, type = "amino_acids"):
        if type not in seq_types:
            raise WrongSeqTypeError("Trying to get a sequence-'type' from the feature table that don't exist, if should be in '{seq_types}' ")
        self.open_cursor.executemany(f"""
        SELECT feature_id,{type} FROM features WHERE feature_id=?;
        """, [(f,) for f in features])
        seqs = {m[0] : m[1] for m in self.open_cursor.fetchall()}
        return seqs

    def get_genome_feats(self, genome_name, type = "amino_acids"):
        if type not in seq_types:
            raise WrongSeqTypeError("Trying to get a sequence-'type' from the feature table that don't exist, if should be in '{seq_types}' ")
        self.open_cursor.execute(f"""
        SELECT feature_id,{type} FROM features INNER JOIN contigs  on contigs.contig_name = features.contig_name WHERE genome_name = ? ;
        """, (genome_name,))
        seqs = {m[0] : m[1] for m in self.open_cursor.fetchall() if m[1]}
        return seqs


    def get_genome(self, genome_name):
        self.open_cursor.execute(f"""
        SELECT contig_name,sequence FROM contigs WHERE genome_name='{genome_name}';
        """)
        data = self.open_cursor.fetchall()
        return data

    def get_random_genome(self):
        from mOTUlizer.classes.MetaBin import MetaBin

        self.open_cursor.execute(f"""
        SELECT genome_name FROM genomes ORDER BY RANDOM() LIMIT 1;
        """)
        data = self.open_cursor.fetchall()

        return MetaBin(name = data[0][0])


    def get_signature(self, genome_name):
        self.open_cursor.execute(f"""
        SELECT signature FROM genomes WHERE genome_name='{genome_name}';
        """)
        data = self.open_cursor.fetchall()[0][0]
        return list(load_signatures(data))[0]

    def get_contigs(self, contigs):
        values = ",".join([f"'{c}'" for c in contigs])
        if len(contigs) == 1:
            self.open_cursor.execute(f"""
            SELECT contig_name,sequence FROM contigs WHERE contig_name={values};
            """)
        else :
            self.open_cursor.execute(f"""
            SELECT contig_name,sequence FROM contigs WHERE contig_name IN ({values});
            """)
        data = self.open_cursor.fetchall()
        return {c[0] : "".join(c[1]) for c in data}

    def get_genome_info(self, genome_name):
        fields = ["genome_name", "source", "annotations", "taxonomy", "completeness", "redundancy"]
        self.open_cursor.execute(f"""
        SELECT {' , '.join(fields)} FROM genomes WHERE genome_name=?;
        """, (genome_name,))
        data = self.open_cursor.fetchall()
        return {k : v for k,v in zip(fields, data[0])}


    def write_genome_fasta(self, name : str, file : str, width = 60):
        data = self.get_genome(name)
        if width:
            chop = lambda d : "".join([d[1][i:i+width] + "\n" for i in range(0, len(d[1]), width)])
        else :
            chop = lambda d : d[1] + "\n"
        with open(file, "w") as handle:
            handle.writelines([f">{d[0]}\n{chop(d)}" for d in data])

    def get_taxonomy(self, genome_ids = None):
        if genome_ids:
            where_line = "WHERE genome_name IN ({names})".format(names = " , ".join([f'"{g}"' for g in genome_ids]))
        else :
            where_line = ""

        self.open_cursor.execute(f"""
        SELECT genome_name, taxonomy FROM genomes {where_line};
        """)
        data = {k : v for k,v in  tqdm(self.open_cursor.fetchall())}
        data = {k : json.loads(v.replace('""','"')) for k,v in tqdm(data.items()) if v}
        return data

    def check_db(self):
        pass
